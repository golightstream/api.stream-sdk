/*
---------------------------------------------------------------------------------------------
Copyright (c) Infiniscene, Inc. All rights reserved.
Licensed under the MIT License. See License.txt in the project root for license information.
---------------------------------------------------------------------------------------------
*/
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: live/v21/api.proto

// API.stream Live API
//
// The Live API enables developers to build video-enabled applications.

package livev21

import (
	context "context"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	AccountConfigurationService_GetAccountConfiguration_FullMethodName    = "/live.v21.AccountConfigurationService/GetAccountConfiguration"
	AccountConfigurationService_UpdateAccountConfiguration_FullMethodName = "/live.v21.AccountConfigurationService/UpdateAccountConfiguration"
)

// AccountConfigurationServiceClient is the client API for AccountConfigurationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountConfigurationServiceClient interface {
	// get account configuration
	GetAccountConfiguration(ctx context.Context, in *GetAccountConfigurationRequest, opts ...grpc.CallOption) (*GetAccountConfigurationResponse, error)
	// update account configuration
	UpdateAccountConfiguration(ctx context.Context, in *UpdateAccountConfigurationRequest, opts ...grpc.CallOption) (*UpdateAccountConfigurationResponse, error)
}

type accountConfigurationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountConfigurationServiceClient(cc grpc.ClientConnInterface) AccountConfigurationServiceClient {
	return &accountConfigurationServiceClient{cc}
}

func (c *accountConfigurationServiceClient) GetAccountConfiguration(ctx context.Context, in *GetAccountConfigurationRequest, opts ...grpc.CallOption) (*GetAccountConfigurationResponse, error) {
	out := new(GetAccountConfigurationResponse)
	err := c.cc.Invoke(ctx, AccountConfigurationService_GetAccountConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountConfigurationServiceClient) UpdateAccountConfiguration(ctx context.Context, in *UpdateAccountConfigurationRequest, opts ...grpc.CallOption) (*UpdateAccountConfigurationResponse, error) {
	out := new(UpdateAccountConfigurationResponse)
	err := c.cc.Invoke(ctx, AccountConfigurationService_UpdateAccountConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountConfigurationServiceServer is the server API for AccountConfigurationService service.
// All implementations should embed UnimplementedAccountConfigurationServiceServer
// for forward compatibility
type AccountConfigurationServiceServer interface {
	// get account configuration
	GetAccountConfiguration(context.Context, *GetAccountConfigurationRequest) (*GetAccountConfigurationResponse, error)
	// update account configuration
	UpdateAccountConfiguration(context.Context, *UpdateAccountConfigurationRequest) (*UpdateAccountConfigurationResponse, error)
}

// UnimplementedAccountConfigurationServiceServer should be embedded to have forward compatible implementations.
type UnimplementedAccountConfigurationServiceServer struct {
}

func (UnimplementedAccountConfigurationServiceServer) GetAccountConfiguration(context.Context, *GetAccountConfigurationRequest) (*GetAccountConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountConfiguration not implemented")
}
func (UnimplementedAccountConfigurationServiceServer) UpdateAccountConfiguration(context.Context, *UpdateAccountConfigurationRequest) (*UpdateAccountConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAccountConfiguration not implemented")
}

// UnsafeAccountConfigurationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountConfigurationServiceServer will
// result in compilation errors.
type UnsafeAccountConfigurationServiceServer interface {
	mustEmbedUnimplementedAccountConfigurationServiceServer()
}

func RegisterAccountConfigurationServiceServer(s grpc.ServiceRegistrar, srv AccountConfigurationServiceServer) {
	s.RegisterService(&AccountConfigurationService_ServiceDesc, srv)
}

func _AccountConfigurationService_GetAccountConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountConfigurationServiceServer).GetAccountConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountConfigurationService_GetAccountConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountConfigurationServiceServer).GetAccountConfiguration(ctx, req.(*GetAccountConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountConfigurationService_UpdateAccountConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAccountConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountConfigurationServiceServer).UpdateAccountConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountConfigurationService_UpdateAccountConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountConfigurationServiceServer).UpdateAccountConfiguration(ctx, req.(*UpdateAccountConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountConfigurationService_ServiceDesc is the grpc.ServiceDesc for AccountConfigurationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountConfigurationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "live.v21.AccountConfigurationService",
	HandlerType: (*AccountConfigurationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccountConfiguration",
			Handler:    _AccountConfigurationService_GetAccountConfiguration_Handler,
		},
		{
			MethodName: "UpdateAccountConfiguration",
			Handler:    _AccountConfigurationService_UpdateAccountConfiguration_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "live/v21/api.proto",
}

const (
	CollectionService_CreateCollection_FullMethodName = "/live.v21.CollectionService/CreateCollection"
	CollectionService_GetCollection_FullMethodName    = "/live.v21.CollectionService/GetCollection"
	CollectionService_GetCollections_FullMethodName   = "/live.v21.CollectionService/GetCollections"
	CollectionService_UpdateCollection_FullMethodName = "/live.v21.CollectionService/UpdateCollection"
	CollectionService_DeleteCollection_FullMethodName = "/live.v21.CollectionService/DeleteCollection"
)

// CollectionServiceClient is the client API for CollectionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CollectionServiceClient interface {
	// Create Collection
	//
	// Create a new collection of related projects and collection live sources
	CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionResponse, error)
	// Get Collection
	//
	// Get an existing collection of related projects and collection live
	// sources
	GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionResponse, error)
	// Get Collections
	//
	// Get all collections owned by the user
	GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error)
	// Update Collection
	//
	// Update select collection document data
	UpdateCollection(ctx context.Context, in *UpdateCollectionRequest, opts ...grpc.CallOption) (*UpdateCollectionResponse, error)
	// Delete Collection
	//
	// Delete a collection of related projects and collection live sources
	DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*DeleteCollectionResponse, error)
}

type collectionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCollectionServiceClient(cc grpc.ClientConnInterface) CollectionServiceClient {
	return &collectionServiceClient{cc}
}

func (c *collectionServiceClient) CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionResponse, error) {
	out := new(CreateCollectionResponse)
	err := c.cc.Invoke(ctx, CollectionService_CreateCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectionServiceClient) GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionResponse, error) {
	out := new(GetCollectionResponse)
	err := c.cc.Invoke(ctx, CollectionService_GetCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectionServiceClient) GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error) {
	out := new(GetCollectionsResponse)
	err := c.cc.Invoke(ctx, CollectionService_GetCollections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectionServiceClient) UpdateCollection(ctx context.Context, in *UpdateCollectionRequest, opts ...grpc.CallOption) (*UpdateCollectionResponse, error) {
	out := new(UpdateCollectionResponse)
	err := c.cc.Invoke(ctx, CollectionService_UpdateCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectionServiceClient) DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*DeleteCollectionResponse, error) {
	out := new(DeleteCollectionResponse)
	err := c.cc.Invoke(ctx, CollectionService_DeleteCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CollectionServiceServer is the server API for CollectionService service.
// All implementations should embed UnimplementedCollectionServiceServer
// for forward compatibility
type CollectionServiceServer interface {
	// Create Collection
	//
	// Create a new collection of related projects and collection live sources
	CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionResponse, error)
	// Get Collection
	//
	// Get an existing collection of related projects and collection live
	// sources
	GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionResponse, error)
	// Get Collections
	//
	// Get all collections owned by the user
	GetCollections(context.Context, *GetCollectionsRequest) (*GetCollectionsResponse, error)
	// Update Collection
	//
	// Update select collection document data
	UpdateCollection(context.Context, *UpdateCollectionRequest) (*UpdateCollectionResponse, error)
	// Delete Collection
	//
	// Delete a collection of related projects and collection live sources
	DeleteCollection(context.Context, *DeleteCollectionRequest) (*DeleteCollectionResponse, error)
}

// UnimplementedCollectionServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCollectionServiceServer struct {
}

func (UnimplementedCollectionServiceServer) CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCollection not implemented")
}
func (UnimplementedCollectionServiceServer) GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollection not implemented")
}
func (UnimplementedCollectionServiceServer) GetCollections(context.Context, *GetCollectionsRequest) (*GetCollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollections not implemented")
}
func (UnimplementedCollectionServiceServer) UpdateCollection(context.Context, *UpdateCollectionRequest) (*UpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollection not implemented")
}
func (UnimplementedCollectionServiceServer) DeleteCollection(context.Context, *DeleteCollectionRequest) (*DeleteCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollection not implemented")
}

// UnsafeCollectionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CollectionServiceServer will
// result in compilation errors.
type UnsafeCollectionServiceServer interface {
	mustEmbedUnimplementedCollectionServiceServer()
}

func RegisterCollectionServiceServer(s grpc.ServiceRegistrar, srv CollectionServiceServer) {
	s.RegisterService(&CollectionService_ServiceDesc, srv)
}

func _CollectionService_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CollectionService_CreateCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).CreateCollection(ctx, req.(*CreateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollectionService_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CollectionService_GetCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).GetCollection(ctx, req.(*GetCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollectionService_GetCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).GetCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CollectionService_GetCollections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).GetCollections(ctx, req.(*GetCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollectionService_UpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).UpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CollectionService_UpdateCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).UpdateCollection(ctx, req.(*UpdateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollectionService_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CollectionService_DeleteCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).DeleteCollection(ctx, req.(*DeleteCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CollectionService_ServiceDesc is the grpc.ServiceDesc for CollectionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CollectionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "live.v21.CollectionService",
	HandlerType: (*CollectionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCollection",
			Handler:    _CollectionService_CreateCollection_Handler,
		},
		{
			MethodName: "GetCollection",
			Handler:    _CollectionService_GetCollection_Handler,
		},
		{
			MethodName: "GetCollections",
			Handler:    _CollectionService_GetCollections_Handler,
		},
		{
			MethodName: "UpdateCollection",
			Handler:    _CollectionService_UpdateCollection_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _CollectionService_DeleteCollection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "live/v21/api.proto",
}

const (
	ProjectService_CreateProject_FullMethodName               = "/live.v21.ProjectService/CreateProject"
	ProjectService_GetProject_FullMethodName                  = "/live.v21.ProjectService/GetProject"
	ProjectService_DeleteProject_FullMethodName               = "/live.v21.ProjectService/DeleteProject"
	ProjectService_UpdateProject_FullMethodName               = "/live.v21.ProjectService/UpdateProject"
	ProjectService_StartProjectBroadcast_FullMethodName       = "/live.v21.ProjectService/StartProjectBroadcast"
	ProjectService_StopProjectBroadcast_FullMethodName        = "/live.v21.ProjectService/StopProjectBroadcast"
	ProjectService_StartProjectWebRtc_FullMethodName          = "/live.v21.ProjectService/StartProjectWebRtc"
	ProjectService_StopProjectWebRtc_FullMethodName           = "/live.v21.ProjectService/StopProjectWebRtc"
	ProjectService_GetProjectBroadcastSnapshot_FullMethodName = "/live.v21.ProjectService/GetProjectBroadcastSnapshot"
	ProjectService_GetProjectBroadcastStatus_FullMethodName   = "/live.v21.ProjectService/GetProjectBroadcastStatus"
)

// ProjectServiceClient is the client API for ProjectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectServiceClient interface {
	// Create Project
	//
	// Create a new project
	CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*CreateProjectResponse, error)
	// Get Project
	//
	// Get an existing project
	GetProject(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*GetProjectResponse, error)
	// Delete Project
	//
	// Delete a project
	DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*DeleteProjectResponse, error)
	// Update Project
	//
	// Updates a project
	UpdateProject(ctx context.Context, in *UpdateProjectRequest, opts ...grpc.CallOption) (*UpdateProjectResponse, error)
	// Start Broadcast
	//
	// Start broadcasting a project
	StartProjectBroadcast(ctx context.Context, in *StartProjectBroadcastRequest, opts ...grpc.CallOption) (*StartProjectBroadcastResponse, error)
	// Stop Broadcast
	//
	// Stop broadcasting a project
	StopProjectBroadcast(ctx context.Context, in *StopProjectBroadcastRequest, opts ...grpc.CallOption) (*StopProjectBroadcastResponse, error)
	// Start WebRTC
	//
	// Start WebRTC services
	StartProjectWebRtc(ctx context.Context, in *StartProjectWebRtcRequest, opts ...grpc.CallOption) (*StartProjectWebRtcResponse, error)
	// Stop WebRTC
	//
	// Stop WebRTC services
	StopProjectWebRtc(ctx context.Context, in *StopProjectWebRtcRequest, opts ...grpc.CallOption) (*StopProjectWebRtcResponse, error)
	// Get Snapshot
	//
	// Get a snapshot of the current output frame of the broadcast
	GetProjectBroadcastSnapshot(ctx context.Context, in *GetProjectBroadcastSnapshotRequest, opts ...grpc.CallOption) (*GetProjectBroadcastSnapshotResponse, error)
	// Get Broadcast Status
	//
	// Get the broadcast status of the project
	GetProjectBroadcastStatus(ctx context.Context, in *GetProjectBroadcastStatusRequest, opts ...grpc.CallOption) (*GetProjectBroadcastStatusResponse, error)
}

type projectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectServiceClient(cc grpc.ClientConnInterface) ProjectServiceClient {
	return &projectServiceClient{cc}
}

func (c *projectServiceClient) CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*CreateProjectResponse, error) {
	out := new(CreateProjectResponse)
	err := c.cc.Invoke(ctx, ProjectService_CreateProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) GetProject(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*GetProjectResponse, error) {
	out := new(GetProjectResponse)
	err := c.cc.Invoke(ctx, ProjectService_GetProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*DeleteProjectResponse, error) {
	out := new(DeleteProjectResponse)
	err := c.cc.Invoke(ctx, ProjectService_DeleteProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) UpdateProject(ctx context.Context, in *UpdateProjectRequest, opts ...grpc.CallOption) (*UpdateProjectResponse, error) {
	out := new(UpdateProjectResponse)
	err := c.cc.Invoke(ctx, ProjectService_UpdateProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) StartProjectBroadcast(ctx context.Context, in *StartProjectBroadcastRequest, opts ...grpc.CallOption) (*StartProjectBroadcastResponse, error) {
	out := new(StartProjectBroadcastResponse)
	err := c.cc.Invoke(ctx, ProjectService_StartProjectBroadcast_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) StopProjectBroadcast(ctx context.Context, in *StopProjectBroadcastRequest, opts ...grpc.CallOption) (*StopProjectBroadcastResponse, error) {
	out := new(StopProjectBroadcastResponse)
	err := c.cc.Invoke(ctx, ProjectService_StopProjectBroadcast_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) StartProjectWebRtc(ctx context.Context, in *StartProjectWebRtcRequest, opts ...grpc.CallOption) (*StartProjectWebRtcResponse, error) {
	out := new(StartProjectWebRtcResponse)
	err := c.cc.Invoke(ctx, ProjectService_StartProjectWebRtc_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) StopProjectWebRtc(ctx context.Context, in *StopProjectWebRtcRequest, opts ...grpc.CallOption) (*StopProjectWebRtcResponse, error) {
	out := new(StopProjectWebRtcResponse)
	err := c.cc.Invoke(ctx, ProjectService_StopProjectWebRtc_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) GetProjectBroadcastSnapshot(ctx context.Context, in *GetProjectBroadcastSnapshotRequest, opts ...grpc.CallOption) (*GetProjectBroadcastSnapshotResponse, error) {
	out := new(GetProjectBroadcastSnapshotResponse)
	err := c.cc.Invoke(ctx, ProjectService_GetProjectBroadcastSnapshot_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) GetProjectBroadcastStatus(ctx context.Context, in *GetProjectBroadcastStatusRequest, opts ...grpc.CallOption) (*GetProjectBroadcastStatusResponse, error) {
	out := new(GetProjectBroadcastStatusResponse)
	err := c.cc.Invoke(ctx, ProjectService_GetProjectBroadcastStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectServiceServer is the server API for ProjectService service.
// All implementations should embed UnimplementedProjectServiceServer
// for forward compatibility
type ProjectServiceServer interface {
	// Create Project
	//
	// Create a new project
	CreateProject(context.Context, *CreateProjectRequest) (*CreateProjectResponse, error)
	// Get Project
	//
	// Get an existing project
	GetProject(context.Context, *GetProjectRequest) (*GetProjectResponse, error)
	// Delete Project
	//
	// Delete a project
	DeleteProject(context.Context, *DeleteProjectRequest) (*DeleteProjectResponse, error)
	// Update Project
	//
	// Updates a project
	UpdateProject(context.Context, *UpdateProjectRequest) (*UpdateProjectResponse, error)
	// Start Broadcast
	//
	// Start broadcasting a project
	StartProjectBroadcast(context.Context, *StartProjectBroadcastRequest) (*StartProjectBroadcastResponse, error)
	// Stop Broadcast
	//
	// Stop broadcasting a project
	StopProjectBroadcast(context.Context, *StopProjectBroadcastRequest) (*StopProjectBroadcastResponse, error)
	// Start WebRTC
	//
	// Start WebRTC services
	StartProjectWebRtc(context.Context, *StartProjectWebRtcRequest) (*StartProjectWebRtcResponse, error)
	// Stop WebRTC
	//
	// Stop WebRTC services
	StopProjectWebRtc(context.Context, *StopProjectWebRtcRequest) (*StopProjectWebRtcResponse, error)
	// Get Snapshot
	//
	// Get a snapshot of the current output frame of the broadcast
	GetProjectBroadcastSnapshot(context.Context, *GetProjectBroadcastSnapshotRequest) (*GetProjectBroadcastSnapshotResponse, error)
	// Get Broadcast Status
	//
	// Get the broadcast status of the project
	GetProjectBroadcastStatus(context.Context, *GetProjectBroadcastStatusRequest) (*GetProjectBroadcastStatusResponse, error)
}

// UnimplementedProjectServiceServer should be embedded to have forward compatible implementations.
type UnimplementedProjectServiceServer struct {
}

func (UnimplementedProjectServiceServer) CreateProject(context.Context, *CreateProjectRequest) (*CreateProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (UnimplementedProjectServiceServer) GetProject(context.Context, *GetProjectRequest) (*GetProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProject not implemented")
}
func (UnimplementedProjectServiceServer) DeleteProject(context.Context, *DeleteProjectRequest) (*DeleteProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProject not implemented")
}
func (UnimplementedProjectServiceServer) UpdateProject(context.Context, *UpdateProjectRequest) (*UpdateProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProject not implemented")
}
func (UnimplementedProjectServiceServer) StartProjectBroadcast(context.Context, *StartProjectBroadcastRequest) (*StartProjectBroadcastResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartProjectBroadcast not implemented")
}
func (UnimplementedProjectServiceServer) StopProjectBroadcast(context.Context, *StopProjectBroadcastRequest) (*StopProjectBroadcastResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopProjectBroadcast not implemented")
}
func (UnimplementedProjectServiceServer) StartProjectWebRtc(context.Context, *StartProjectWebRtcRequest) (*StartProjectWebRtcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartProjectWebRtc not implemented")
}
func (UnimplementedProjectServiceServer) StopProjectWebRtc(context.Context, *StopProjectWebRtcRequest) (*StopProjectWebRtcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopProjectWebRtc not implemented")
}
func (UnimplementedProjectServiceServer) GetProjectBroadcastSnapshot(context.Context, *GetProjectBroadcastSnapshotRequest) (*GetProjectBroadcastSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectBroadcastSnapshot not implemented")
}
func (UnimplementedProjectServiceServer) GetProjectBroadcastStatus(context.Context, *GetProjectBroadcastStatusRequest) (*GetProjectBroadcastStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectBroadcastStatus not implemented")
}

// UnsafeProjectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectServiceServer will
// result in compilation errors.
type UnsafeProjectServiceServer interface {
	mustEmbedUnimplementedProjectServiceServer()
}

func RegisterProjectServiceServer(s grpc.ServiceRegistrar, srv ProjectServiceServer) {
	s.RegisterService(&ProjectService_ServiceDesc, srv)
}

func _ProjectService_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_CreateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).CreateProject(ctx, req.(*CreateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_GetProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).GetProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_GetProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).GetProject(ctx, req.(*GetProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_DeleteProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).DeleteProject(ctx, req.(*DeleteProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_UpdateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).UpdateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_UpdateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).UpdateProject(ctx, req.(*UpdateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_StartProjectBroadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProjectBroadcastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).StartProjectBroadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_StartProjectBroadcast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).StartProjectBroadcast(ctx, req.(*StartProjectBroadcastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_StopProjectBroadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopProjectBroadcastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).StopProjectBroadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_StopProjectBroadcast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).StopProjectBroadcast(ctx, req.(*StopProjectBroadcastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_StartProjectWebRtc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProjectWebRtcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).StartProjectWebRtc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_StartProjectWebRtc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).StartProjectWebRtc(ctx, req.(*StartProjectWebRtcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_StopProjectWebRtc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopProjectWebRtcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).StopProjectWebRtc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_StopProjectWebRtc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).StopProjectWebRtc(ctx, req.(*StopProjectWebRtcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_GetProjectBroadcastSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectBroadcastSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).GetProjectBroadcastSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_GetProjectBroadcastSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).GetProjectBroadcastSnapshot(ctx, req.(*GetProjectBroadcastSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_GetProjectBroadcastStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectBroadcastStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).GetProjectBroadcastStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_GetProjectBroadcastStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).GetProjectBroadcastStatus(ctx, req.(*GetProjectBroadcastStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectService_ServiceDesc is the grpc.ServiceDesc for ProjectService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "live.v21.ProjectService",
	HandlerType: (*ProjectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProject",
			Handler:    _ProjectService_CreateProject_Handler,
		},
		{
			MethodName: "GetProject",
			Handler:    _ProjectService_GetProject_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _ProjectService_DeleteProject_Handler,
		},
		{
			MethodName: "UpdateProject",
			Handler:    _ProjectService_UpdateProject_Handler,
		},
		{
			MethodName: "StartProjectBroadcast",
			Handler:    _ProjectService_StartProjectBroadcast_Handler,
		},
		{
			MethodName: "StopProjectBroadcast",
			Handler:    _ProjectService_StopProjectBroadcast_Handler,
		},
		{
			MethodName: "StartProjectWebRtc",
			Handler:    _ProjectService_StartProjectWebRtc_Handler,
		},
		{
			MethodName: "StopProjectWebRtc",
			Handler:    _ProjectService_StopProjectWebRtc_Handler,
		},
		{
			MethodName: "GetProjectBroadcastSnapshot",
			Handler:    _ProjectService_GetProjectBroadcastSnapshot_Handler,
		},
		{
			MethodName: "GetProjectBroadcastStatus",
			Handler:    _ProjectService_GetProjectBroadcastStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "live/v21/api.proto",
}

const (
	DestinationService_CreateDestination_FullMethodName = "/live.v21.DestinationService/CreateDestination"
	DestinationService_GetDestination_FullMethodName    = "/live.v21.DestinationService/GetDestination"
	DestinationService_UpdateDestination_FullMethodName = "/live.v21.DestinationService/UpdateDestination"
	DestinationService_DeleteDestination_FullMethodName = "/live.v21.DestinationService/DeleteDestination"
)

// DestinationServiceClient is the client API for DestinationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DestinationServiceClient interface {
	// Create Destination
	//
	// Create a new Destination
	CreateDestination(ctx context.Context, in *CreateDestinationRequest, opts ...grpc.CallOption) (*CreateDestinationResponse, error)
	// Get Destination
	//
	// Get an existing Destination.
	GetDestination(ctx context.Context, in *GetDestinationRequest, opts ...grpc.CallOption) (*GetDestinationResponse, error)
	// Update Destination
	//
	// Update a destination
	UpdateDestination(ctx context.Context, in *UpdateDestinationRequest, opts ...grpc.CallOption) (*UpdateDestinationResponse, error)
	// Delete Destination
	//
	// Delete a destination
	DeleteDestination(ctx context.Context, in *DeleteDestinationRequest, opts ...grpc.CallOption) (*DeleteDestinationResponse, error)
}

type destinationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDestinationServiceClient(cc grpc.ClientConnInterface) DestinationServiceClient {
	return &destinationServiceClient{cc}
}

func (c *destinationServiceClient) CreateDestination(ctx context.Context, in *CreateDestinationRequest, opts ...grpc.CallOption) (*CreateDestinationResponse, error) {
	out := new(CreateDestinationResponse)
	err := c.cc.Invoke(ctx, DestinationService_CreateDestination_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *destinationServiceClient) GetDestination(ctx context.Context, in *GetDestinationRequest, opts ...grpc.CallOption) (*GetDestinationResponse, error) {
	out := new(GetDestinationResponse)
	err := c.cc.Invoke(ctx, DestinationService_GetDestination_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *destinationServiceClient) UpdateDestination(ctx context.Context, in *UpdateDestinationRequest, opts ...grpc.CallOption) (*UpdateDestinationResponse, error) {
	out := new(UpdateDestinationResponse)
	err := c.cc.Invoke(ctx, DestinationService_UpdateDestination_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *destinationServiceClient) DeleteDestination(ctx context.Context, in *DeleteDestinationRequest, opts ...grpc.CallOption) (*DeleteDestinationResponse, error) {
	out := new(DeleteDestinationResponse)
	err := c.cc.Invoke(ctx, DestinationService_DeleteDestination_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DestinationServiceServer is the server API for DestinationService service.
// All implementations should embed UnimplementedDestinationServiceServer
// for forward compatibility
type DestinationServiceServer interface {
	// Create Destination
	//
	// Create a new Destination
	CreateDestination(context.Context, *CreateDestinationRequest) (*CreateDestinationResponse, error)
	// Get Destination
	//
	// Get an existing Destination.
	GetDestination(context.Context, *GetDestinationRequest) (*GetDestinationResponse, error)
	// Update Destination
	//
	// Update a destination
	UpdateDestination(context.Context, *UpdateDestinationRequest) (*UpdateDestinationResponse, error)
	// Delete Destination
	//
	// Delete a destination
	DeleteDestination(context.Context, *DeleteDestinationRequest) (*DeleteDestinationResponse, error)
}

// UnimplementedDestinationServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDestinationServiceServer struct {
}

func (UnimplementedDestinationServiceServer) CreateDestination(context.Context, *CreateDestinationRequest) (*CreateDestinationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDestination not implemented")
}
func (UnimplementedDestinationServiceServer) GetDestination(context.Context, *GetDestinationRequest) (*GetDestinationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDestination not implemented")
}
func (UnimplementedDestinationServiceServer) UpdateDestination(context.Context, *UpdateDestinationRequest) (*UpdateDestinationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDestination not implemented")
}
func (UnimplementedDestinationServiceServer) DeleteDestination(context.Context, *DeleteDestinationRequest) (*DeleteDestinationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDestination not implemented")
}

// UnsafeDestinationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DestinationServiceServer will
// result in compilation errors.
type UnsafeDestinationServiceServer interface {
	mustEmbedUnimplementedDestinationServiceServer()
}

func RegisterDestinationServiceServer(s grpc.ServiceRegistrar, srv DestinationServiceServer) {
	s.RegisterService(&DestinationService_ServiceDesc, srv)
}

func _DestinationService_CreateDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDestinationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DestinationServiceServer).CreateDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DestinationService_CreateDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DestinationServiceServer).CreateDestination(ctx, req.(*CreateDestinationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DestinationService_GetDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDestinationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DestinationServiceServer).GetDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DestinationService_GetDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DestinationServiceServer).GetDestination(ctx, req.(*GetDestinationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DestinationService_UpdateDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDestinationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DestinationServiceServer).UpdateDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DestinationService_UpdateDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DestinationServiceServer).UpdateDestination(ctx, req.(*UpdateDestinationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DestinationService_DeleteDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDestinationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DestinationServiceServer).DeleteDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DestinationService_DeleteDestination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DestinationServiceServer).DeleteDestination(ctx, req.(*DeleteDestinationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DestinationService_ServiceDesc is the grpc.ServiceDesc for DestinationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DestinationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "live.v21.DestinationService",
	HandlerType: (*DestinationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDestination",
			Handler:    _DestinationService_CreateDestination_Handler,
		},
		{
			MethodName: "GetDestination",
			Handler:    _DestinationService_GetDestination_Handler,
		},
		{
			MethodName: "UpdateDestination",
			Handler:    _DestinationService_UpdateDestination_Handler,
		},
		{
			MethodName: "DeleteDestination",
			Handler:    _DestinationService_DeleteDestination_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "live/v21/api.proto",
}

const (
	SourceService_CreateSource_FullMethodName            = "/live.v21.SourceService/CreateSource"
	SourceService_DeleteSource_FullMethodName            = "/live.v21.SourceService/DeleteSource"
	SourceService_UpdateSource_FullMethodName            = "/live.v21.SourceService/UpdateSource"
	SourceService_UpdateSourceInProject_FullMethodName   = "/live.v21.SourceService/UpdateSourceInProject"
	SourceService_GetSource_FullMethodName               = "/live.v21.SourceService/GetSource"
	SourceService_GetSources_FullMethodName              = "/live.v21.SourceService/GetSources"
	SourceService_AddSourceToProject_FullMethodName      = "/live.v21.SourceService/AddSourceToProject"
	SourceService_RemoveSourceFromProject_FullMethodName = "/live.v21.SourceService/RemoveSourceFromProject"
	SourceService_GetSourcePlaylist_FullMethodName       = "/live.v21.SourceService/GetSourcePlaylist"
)

// SourceServiceClient is the client API for SourceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SourceServiceClient interface {
	// Create Collection Live Source
	//
	// Create a new live source in a collection
	// ### Permissions
	// * scope: `SCOPE_VAPI_CREATE`
	CreateSource(ctx context.Context, in *CreateSourceRequest, opts ...grpc.CallOption) (*CreateSourceResponse, error)
	// Delete Live Source
	//
	// Deletes a live source from a collection
	DeleteSource(ctx context.Context, in *DeleteSourceRequest, opts ...grpc.CallOption) (*DeleteSourceResponse, error)
	// Update Source
	//
	// Update attributes of the Source.
	UpdateSource(ctx context.Context, in *UpdateSourceRequest, opts ...grpc.CallOption) (*UpdateSourceResponse, error)
	// Update Source
	//
	// Update attributes of the Source.
	UpdateSourceInProject(ctx context.Context, in *UpdateSourceInProjectRequest, opts ...grpc.CallOption) (*UpdateSourceInProjectResponse, error)
	// Get Source
	//
	// Get an existing source in a project
	GetSource(ctx context.Context, in *GetSourceRequest, opts ...grpc.CallOption) (*GetSourceResponse, error)
	// Get Source
	//
	// Get existing sources in a collection
	GetSources(ctx context.Context, in *GetSourcesRequest, opts ...grpc.CallOption) (*GetSourcesResponse, error)
	// Add Source to Project
	//
	// Add a source to a project
	AddSourceToProject(ctx context.Context, in *AddSourceToProjectRequest, opts ...grpc.CallOption) (*AddSourceToProjectResponse, error)
	// Delete Source From Project
	//
	// Removes a source from a project.
	RemoveSourceFromProject(ctx context.Context, in *RemoveSourceFromProjectRequest, opts ...grpc.CallOption) (*RemoveSourceFromProjectResponse, error)
	// Get the HLS playlist for a source.
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	GetSourcePlaylist(ctx context.Context, in *GetSourcePlaylistRequest, opts ...grpc.CallOption) (*httpbody.HttpBody, error)
}

type sourceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSourceServiceClient(cc grpc.ClientConnInterface) SourceServiceClient {
	return &sourceServiceClient{cc}
}

func (c *sourceServiceClient) CreateSource(ctx context.Context, in *CreateSourceRequest, opts ...grpc.CallOption) (*CreateSourceResponse, error) {
	out := new(CreateSourceResponse)
	err := c.cc.Invoke(ctx, SourceService_CreateSource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceServiceClient) DeleteSource(ctx context.Context, in *DeleteSourceRequest, opts ...grpc.CallOption) (*DeleteSourceResponse, error) {
	out := new(DeleteSourceResponse)
	err := c.cc.Invoke(ctx, SourceService_DeleteSource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceServiceClient) UpdateSource(ctx context.Context, in *UpdateSourceRequest, opts ...grpc.CallOption) (*UpdateSourceResponse, error) {
	out := new(UpdateSourceResponse)
	err := c.cc.Invoke(ctx, SourceService_UpdateSource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceServiceClient) UpdateSourceInProject(ctx context.Context, in *UpdateSourceInProjectRequest, opts ...grpc.CallOption) (*UpdateSourceInProjectResponse, error) {
	out := new(UpdateSourceInProjectResponse)
	err := c.cc.Invoke(ctx, SourceService_UpdateSourceInProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceServiceClient) GetSource(ctx context.Context, in *GetSourceRequest, opts ...grpc.CallOption) (*GetSourceResponse, error) {
	out := new(GetSourceResponse)
	err := c.cc.Invoke(ctx, SourceService_GetSource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceServiceClient) GetSources(ctx context.Context, in *GetSourcesRequest, opts ...grpc.CallOption) (*GetSourcesResponse, error) {
	out := new(GetSourcesResponse)
	err := c.cc.Invoke(ctx, SourceService_GetSources_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceServiceClient) AddSourceToProject(ctx context.Context, in *AddSourceToProjectRequest, opts ...grpc.CallOption) (*AddSourceToProjectResponse, error) {
	out := new(AddSourceToProjectResponse)
	err := c.cc.Invoke(ctx, SourceService_AddSourceToProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceServiceClient) RemoveSourceFromProject(ctx context.Context, in *RemoveSourceFromProjectRequest, opts ...grpc.CallOption) (*RemoveSourceFromProjectResponse, error) {
	out := new(RemoveSourceFromProjectResponse)
	err := c.cc.Invoke(ctx, SourceService_RemoveSourceFromProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourceServiceClient) GetSourcePlaylist(ctx context.Context, in *GetSourcePlaylistRequest, opts ...grpc.CallOption) (*httpbody.HttpBody, error) {
	out := new(httpbody.HttpBody)
	err := c.cc.Invoke(ctx, SourceService_GetSourcePlaylist_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SourceServiceServer is the server API for SourceService service.
// All implementations should embed UnimplementedSourceServiceServer
// for forward compatibility
type SourceServiceServer interface {
	// Create Collection Live Source
	//
	// Create a new live source in a collection
	// ### Permissions
	// * scope: `SCOPE_VAPI_CREATE`
	CreateSource(context.Context, *CreateSourceRequest) (*CreateSourceResponse, error)
	// Delete Live Source
	//
	// Deletes a live source from a collection
	DeleteSource(context.Context, *DeleteSourceRequest) (*DeleteSourceResponse, error)
	// Update Source
	//
	// Update attributes of the Source.
	UpdateSource(context.Context, *UpdateSourceRequest) (*UpdateSourceResponse, error)
	// Update Source
	//
	// Update attributes of the Source.
	UpdateSourceInProject(context.Context, *UpdateSourceInProjectRequest) (*UpdateSourceInProjectResponse, error)
	// Get Source
	//
	// Get an existing source in a project
	GetSource(context.Context, *GetSourceRequest) (*GetSourceResponse, error)
	// Get Source
	//
	// Get existing sources in a collection
	GetSources(context.Context, *GetSourcesRequest) (*GetSourcesResponse, error)
	// Add Source to Project
	//
	// Add a source to a project
	AddSourceToProject(context.Context, *AddSourceToProjectRequest) (*AddSourceToProjectResponse, error)
	// Delete Source From Project
	//
	// Removes a source from a project.
	RemoveSourceFromProject(context.Context, *RemoveSourceFromProjectRequest) (*RemoveSourceFromProjectResponse, error)
	// Get the HLS playlist for a source.
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	GetSourcePlaylist(context.Context, *GetSourcePlaylistRequest) (*httpbody.HttpBody, error)
}

// UnimplementedSourceServiceServer should be embedded to have forward compatible implementations.
type UnimplementedSourceServiceServer struct {
}

func (UnimplementedSourceServiceServer) CreateSource(context.Context, *CreateSourceRequest) (*CreateSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSource not implemented")
}
func (UnimplementedSourceServiceServer) DeleteSource(context.Context, *DeleteSourceRequest) (*DeleteSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSource not implemented")
}
func (UnimplementedSourceServiceServer) UpdateSource(context.Context, *UpdateSourceRequest) (*UpdateSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSource not implemented")
}
func (UnimplementedSourceServiceServer) UpdateSourceInProject(context.Context, *UpdateSourceInProjectRequest) (*UpdateSourceInProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSourceInProject not implemented")
}
func (UnimplementedSourceServiceServer) GetSource(context.Context, *GetSourceRequest) (*GetSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSource not implemented")
}
func (UnimplementedSourceServiceServer) GetSources(context.Context, *GetSourcesRequest) (*GetSourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSources not implemented")
}
func (UnimplementedSourceServiceServer) AddSourceToProject(context.Context, *AddSourceToProjectRequest) (*AddSourceToProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSourceToProject not implemented")
}
func (UnimplementedSourceServiceServer) RemoveSourceFromProject(context.Context, *RemoveSourceFromProjectRequest) (*RemoveSourceFromProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSourceFromProject not implemented")
}
func (UnimplementedSourceServiceServer) GetSourcePlaylist(context.Context, *GetSourcePlaylistRequest) (*httpbody.HttpBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSourcePlaylist not implemented")
}

// UnsafeSourceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SourceServiceServer will
// result in compilation errors.
type UnsafeSourceServiceServer interface {
	mustEmbedUnimplementedSourceServiceServer()
}

func RegisterSourceServiceServer(s grpc.ServiceRegistrar, srv SourceServiceServer) {
	s.RegisterService(&SourceService_ServiceDesc, srv)
}

func _SourceService_CreateSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).CreateSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_CreateSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).CreateSource(ctx, req.(*CreateSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceService_DeleteSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).DeleteSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_DeleteSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).DeleteSource(ctx, req.(*DeleteSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceService_UpdateSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).UpdateSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_UpdateSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).UpdateSource(ctx, req.(*UpdateSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceService_UpdateSourceInProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSourceInProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).UpdateSourceInProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_UpdateSourceInProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).UpdateSourceInProject(ctx, req.(*UpdateSourceInProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceService_GetSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).GetSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_GetSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).GetSource(ctx, req.(*GetSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceService_GetSources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).GetSources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_GetSources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).GetSources(ctx, req.(*GetSourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceService_AddSourceToProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSourceToProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).AddSourceToProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_AddSourceToProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).AddSourceToProject(ctx, req.(*AddSourceToProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceService_RemoveSourceFromProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSourceFromProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).RemoveSourceFromProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_RemoveSourceFromProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).RemoveSourceFromProject(ctx, req.(*RemoveSourceFromProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourceService_GetSourcePlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSourcePlaylistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourceServiceServer).GetSourcePlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourceService_GetSourcePlaylist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourceServiceServer).GetSourcePlaylist(ctx, req.(*GetSourcePlaylistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SourceService_ServiceDesc is the grpc.ServiceDesc for SourceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SourceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "live.v21.SourceService",
	HandlerType: (*SourceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSource",
			Handler:    _SourceService_CreateSource_Handler,
		},
		{
			MethodName: "DeleteSource",
			Handler:    _SourceService_DeleteSource_Handler,
		},
		{
			MethodName: "UpdateSource",
			Handler:    _SourceService_UpdateSource_Handler,
		},
		{
			MethodName: "UpdateSourceInProject",
			Handler:    _SourceService_UpdateSourceInProject_Handler,
		},
		{
			MethodName: "GetSource",
			Handler:    _SourceService_GetSource_Handler,
		},
		{
			MethodName: "GetSources",
			Handler:    _SourceService_GetSources_Handler,
		},
		{
			MethodName: "AddSourceToProject",
			Handler:    _SourceService_AddSourceToProject_Handler,
		},
		{
			MethodName: "RemoveSourceFromProject",
			Handler:    _SourceService_RemoveSourceFromProject_Handler,
		},
		{
			MethodName: "GetSourcePlaylist",
			Handler:    _SourceService_GetSourcePlaylist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "live/v21/api.proto",
}

const (
	BackendAuthenticationService_CreateAccessToken_FullMethodName = "/live.v21.BackendAuthenticationService/CreateAccessToken"
)

// BackendAuthenticationServiceClient is the client API for BackendAuthenticationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BackendAuthenticationServiceClient interface {
	// Create Access Token
	//
	// Create an access token for a session host
	CreateAccessToken(ctx context.Context, in *CreateAccessTokenRequest, opts ...grpc.CallOption) (*CreateAccessTokenResponse, error)
}

type backendAuthenticationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBackendAuthenticationServiceClient(cc grpc.ClientConnInterface) BackendAuthenticationServiceClient {
	return &backendAuthenticationServiceClient{cc}
}

func (c *backendAuthenticationServiceClient) CreateAccessToken(ctx context.Context, in *CreateAccessTokenRequest, opts ...grpc.CallOption) (*CreateAccessTokenResponse, error) {
	out := new(CreateAccessTokenResponse)
	err := c.cc.Invoke(ctx, BackendAuthenticationService_CreateAccessToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackendAuthenticationServiceServer is the server API for BackendAuthenticationService service.
// All implementations should embed UnimplementedBackendAuthenticationServiceServer
// for forward compatibility
type BackendAuthenticationServiceServer interface {
	// Create Access Token
	//
	// Create an access token for a session host
	CreateAccessToken(context.Context, *CreateAccessTokenRequest) (*CreateAccessTokenResponse, error)
}

// UnimplementedBackendAuthenticationServiceServer should be embedded to have forward compatible implementations.
type UnimplementedBackendAuthenticationServiceServer struct {
}

func (UnimplementedBackendAuthenticationServiceServer) CreateAccessToken(context.Context, *CreateAccessTokenRequest) (*CreateAccessTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccessToken not implemented")
}

// UnsafeBackendAuthenticationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackendAuthenticationServiceServer will
// result in compilation errors.
type UnsafeBackendAuthenticationServiceServer interface {
	mustEmbedUnimplementedBackendAuthenticationServiceServer()
}

func RegisterBackendAuthenticationServiceServer(s grpc.ServiceRegistrar, srv BackendAuthenticationServiceServer) {
	s.RegisterService(&BackendAuthenticationService_ServiceDesc, srv)
}

func _BackendAuthenticationService_CreateAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendAuthenticationServiceServer).CreateAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendAuthenticationService_CreateAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendAuthenticationServiceServer).CreateAccessToken(ctx, req.(*CreateAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BackendAuthenticationService_ServiceDesc is the grpc.ServiceDesc for BackendAuthenticationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackendAuthenticationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "live.v21.BackendAuthenticationService",
	HandlerType: (*BackendAuthenticationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAccessToken",
			Handler:    _BackendAuthenticationService_CreateAccessToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "live/v21/api.proto",
}

const (
	AuthenticationService_CreateGuestAccessToken_FullMethodName  = "/live.v21.AuthenticationService/CreateGuestAccessToken"
	AuthenticationService_RefreshAccessToken_FullMethodName      = "/live.v21.AuthenticationService/RefreshAccessToken"
	AuthenticationService_CreateWebRtcAccessToken_FullMethodName = "/live.v21.AuthenticationService/CreateWebRtcAccessToken"
)

// AuthenticationServiceClient is the client API for AuthenticationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthenticationServiceClient interface {
	// Create Guest Access Token
	//
	// Create an access token for a guest
	CreateGuestAccessToken(ctx context.Context, in *CreateGuestAccessTokenRequest, opts ...grpc.CallOption) (*CreateGuestAccessTokenResponse, error)
	// Refresh Access Token
	//
	// Forcibly refresh an access token prior to expiration
	RefreshAccessToken(ctx context.Context, in *RefreshAccessTokenRequest, opts ...grpc.CallOption) (*RefreshAccessTokenResponse, error)
	// Create WebRTC Access Token
	//
	// Create a WebRTC Access Token
	CreateWebRtcAccessToken(ctx context.Context, in *CreateWebRtcAccessTokenRequest, opts ...grpc.CallOption) (*CreateWebRtcAccessTokenResponse, error)
}

type authenticationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthenticationServiceClient(cc grpc.ClientConnInterface) AuthenticationServiceClient {
	return &authenticationServiceClient{cc}
}

func (c *authenticationServiceClient) CreateGuestAccessToken(ctx context.Context, in *CreateGuestAccessTokenRequest, opts ...grpc.CallOption) (*CreateGuestAccessTokenResponse, error) {
	out := new(CreateGuestAccessTokenResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_CreateGuestAccessToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) RefreshAccessToken(ctx context.Context, in *RefreshAccessTokenRequest, opts ...grpc.CallOption) (*RefreshAccessTokenResponse, error) {
	out := new(RefreshAccessTokenResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_RefreshAccessToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) CreateWebRtcAccessToken(ctx context.Context, in *CreateWebRtcAccessTokenRequest, opts ...grpc.CallOption) (*CreateWebRtcAccessTokenResponse, error) {
	out := new(CreateWebRtcAccessTokenResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_CreateWebRtcAccessToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthenticationServiceServer is the server API for AuthenticationService service.
// All implementations should embed UnimplementedAuthenticationServiceServer
// for forward compatibility
type AuthenticationServiceServer interface {
	// Create Guest Access Token
	//
	// Create an access token for a guest
	CreateGuestAccessToken(context.Context, *CreateGuestAccessTokenRequest) (*CreateGuestAccessTokenResponse, error)
	// Refresh Access Token
	//
	// Forcibly refresh an access token prior to expiration
	RefreshAccessToken(context.Context, *RefreshAccessTokenRequest) (*RefreshAccessTokenResponse, error)
	// Create WebRTC Access Token
	//
	// Create a WebRTC Access Token
	CreateWebRtcAccessToken(context.Context, *CreateWebRtcAccessTokenRequest) (*CreateWebRtcAccessTokenResponse, error)
}

// UnimplementedAuthenticationServiceServer should be embedded to have forward compatible implementations.
type UnimplementedAuthenticationServiceServer struct {
}

func (UnimplementedAuthenticationServiceServer) CreateGuestAccessToken(context.Context, *CreateGuestAccessTokenRequest) (*CreateGuestAccessTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGuestAccessToken not implemented")
}
func (UnimplementedAuthenticationServiceServer) RefreshAccessToken(context.Context, *RefreshAccessTokenRequest) (*RefreshAccessTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshAccessToken not implemented")
}
func (UnimplementedAuthenticationServiceServer) CreateWebRtcAccessToken(context.Context, *CreateWebRtcAccessTokenRequest) (*CreateWebRtcAccessTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWebRtcAccessToken not implemented")
}

// UnsafeAuthenticationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthenticationServiceServer will
// result in compilation errors.
type UnsafeAuthenticationServiceServer interface {
	mustEmbedUnimplementedAuthenticationServiceServer()
}

func RegisterAuthenticationServiceServer(s grpc.ServiceRegistrar, srv AuthenticationServiceServer) {
	s.RegisterService(&AuthenticationService_ServiceDesc, srv)
}

func _AuthenticationService_CreateGuestAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGuestAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).CreateGuestAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_CreateGuestAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).CreateGuestAccessToken(ctx, req.(*CreateGuestAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_RefreshAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).RefreshAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_RefreshAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).RefreshAccessToken(ctx, req.(*RefreshAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_CreateWebRtcAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWebRtcAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).CreateWebRtcAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_CreateWebRtcAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).CreateWebRtcAccessToken(ctx, req.(*CreateWebRtcAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthenticationService_ServiceDesc is the grpc.ServiceDesc for AuthenticationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthenticationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "live.v21.AuthenticationService",
	HandlerType: (*AuthenticationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGuestAccessToken",
			Handler:    _AuthenticationService_CreateGuestAccessToken_Handler,
		},
		{
			MethodName: "RefreshAccessToken",
			Handler:    _AuthenticationService_RefreshAccessToken_Handler,
		},
		{
			MethodName: "CreateWebRtcAccessToken",
			Handler:    _AuthenticationService_CreateWebRtcAccessToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "live/v21/api.proto",
}

const (
	PublicAuthenticationService_GetJsonWebKeySet_FullMethodName  = "/live.v21.PublicAuthenticationService/GetJsonWebKeySet"
	PublicAuthenticationService_GuestCodeRedirect_FullMethodName = "/live.v21.PublicAuthenticationService/GuestCodeRedirect"
)

// PublicAuthenticationServiceClient is the client API for PublicAuthenticationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublicAuthenticationServiceClient interface {
	// Get Public Keys
	//
	// Get public keys used to sign access tokens
	GetJsonWebKeySet(ctx context.Context, in *GetJsonWebKeySetRequest, opts ...grpc.CallOption) (*GetJsonWebKeySetResponse, error)
	// Exchange Guest Access Token
	//
	// Exchange a guest access token with updated user identifiers
	GuestCodeRedirect(ctx context.Context, in *GuestCodeRedirectRequest, opts ...grpc.CallOption) (*GuestCodeRedirectResponse, error)
}

type publicAuthenticationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPublicAuthenticationServiceClient(cc grpc.ClientConnInterface) PublicAuthenticationServiceClient {
	return &publicAuthenticationServiceClient{cc}
}

func (c *publicAuthenticationServiceClient) GetJsonWebKeySet(ctx context.Context, in *GetJsonWebKeySetRequest, opts ...grpc.CallOption) (*GetJsonWebKeySetResponse, error) {
	out := new(GetJsonWebKeySetResponse)
	err := c.cc.Invoke(ctx, PublicAuthenticationService_GetJsonWebKeySet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAuthenticationServiceClient) GuestCodeRedirect(ctx context.Context, in *GuestCodeRedirectRequest, opts ...grpc.CallOption) (*GuestCodeRedirectResponse, error) {
	out := new(GuestCodeRedirectResponse)
	err := c.cc.Invoke(ctx, PublicAuthenticationService_GuestCodeRedirect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublicAuthenticationServiceServer is the server API for PublicAuthenticationService service.
// All implementations should embed UnimplementedPublicAuthenticationServiceServer
// for forward compatibility
type PublicAuthenticationServiceServer interface {
	// Get Public Keys
	//
	// Get public keys used to sign access tokens
	GetJsonWebKeySet(context.Context, *GetJsonWebKeySetRequest) (*GetJsonWebKeySetResponse, error)
	// Exchange Guest Access Token
	//
	// Exchange a guest access token with updated user identifiers
	GuestCodeRedirect(context.Context, *GuestCodeRedirectRequest) (*GuestCodeRedirectResponse, error)
}

// UnimplementedPublicAuthenticationServiceServer should be embedded to have forward compatible implementations.
type UnimplementedPublicAuthenticationServiceServer struct {
}

func (UnimplementedPublicAuthenticationServiceServer) GetJsonWebKeySet(context.Context, *GetJsonWebKeySetRequest) (*GetJsonWebKeySetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJsonWebKeySet not implemented")
}
func (UnimplementedPublicAuthenticationServiceServer) GuestCodeRedirect(context.Context, *GuestCodeRedirectRequest) (*GuestCodeRedirectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GuestCodeRedirect not implemented")
}

// UnsafePublicAuthenticationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublicAuthenticationServiceServer will
// result in compilation errors.
type UnsafePublicAuthenticationServiceServer interface {
	mustEmbedUnimplementedPublicAuthenticationServiceServer()
}

func RegisterPublicAuthenticationServiceServer(s grpc.ServiceRegistrar, srv PublicAuthenticationServiceServer) {
	s.RegisterService(&PublicAuthenticationService_ServiceDesc, srv)
}

func _PublicAuthenticationService_GetJsonWebKeySet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJsonWebKeySetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAuthenticationServiceServer).GetJsonWebKeySet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAuthenticationService_GetJsonWebKeySet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAuthenticationServiceServer).GetJsonWebKeySet(ctx, req.(*GetJsonWebKeySetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAuthenticationService_GuestCodeRedirect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GuestCodeRedirectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAuthenticationServiceServer).GuestCodeRedirect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAuthenticationService_GuestCodeRedirect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAuthenticationServiceServer).GuestCodeRedirect(ctx, req.(*GuestCodeRedirectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PublicAuthenticationService_ServiceDesc is the grpc.ServiceDesc for PublicAuthenticationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PublicAuthenticationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "live.v21.PublicAuthenticationService",
	HandlerType: (*PublicAuthenticationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJsonWebKeySet",
			Handler:    _PublicAuthenticationService_GetJsonWebKeySet_Handler,
		},
		{
			MethodName: "GuestCodeRedirect",
			Handler:    _PublicAuthenticationService_GuestCodeRedirect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "live/v21/api.proto",
}
